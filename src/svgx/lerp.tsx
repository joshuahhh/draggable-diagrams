import { prettyLog, PrettyPrint } from "@joshuahhh/pretty-print";
import { rgb } from "d3-color";
import { interpolateCubehelix } from "d3-interpolate";
import { interpolatePath } from "d3-interpolate-path";
import React, { cloneElement } from "react";
import { shouldRecurseIntoChildren, Svgx } from ".";
import { ErrorWithJSX } from "../ErrorBoundary";
import { emptyToUndefined } from "../utils";
import { LayeredSvgx } from "./layers";
import { lerpTransformString } from "./transform";

// SVG properties that should be interpolated as colors
const COLOR_PROPS = new Set([
  "fill",
  "stroke",
  "color",
  "stop-color",
  "flood-color",
  "lighting-color",
  // CSS properties that can appear in style objects
  "backgroundColor",
  "borderColor",
  "outlineColor",
]);

const NO_LERP_PROPS = new Set(["pointerEvents"]);

const DEFAULT_VALUE_FOR_KEY: { [key: string]: any } = {
  opacity: 1,
};

/**
 * Parses a points string (e.g., "0,0 10,5 20,10") into an array of [x, y] pairs.
 */
function parsePoints(pointsStr: string): number[][] {
  // Split on whitespace and/or commas, filter empty strings
  const tokens = pointsStr
    .trim()
    .split(/[\s,]+/)
    .filter((s) => s.length > 0)
    .map((s) => parseFloat(s));

  const points: number[][] = [];
  for (let i = 0; i < tokens.length; i += 2) {
    points.push([tokens[i], tokens[i + 1]]);
  }
  return points;
}

/**
 * Serializes an array of [x, y] pairs back to a points string.
 */
function serializePoints(points: number[][]): string {
  return points.map((p) => `${p[0]},${p[1]}`).join(" ");
}

/**
 * Lerps between two points strings.
 */
function lerpPoints(pointsA: string, pointsB: string, t: number): string {
  const parsedA = parsePoints(pointsA);
  const parsedB = parsePoints(pointsB);

  if (parsedA.length !== parsedB.length) {
    throw new Error(
      `Cannot lerp points: different point counts (${parsedA.length} vs ${parsedB.length})`,
    );
  }

  const lerped = parsedA.map((pa, i) => {
    const pb = parsedB[i];
    return [lerp(pa[0], pb[0], t), lerp(pa[1], pb[1], t)];
  });

  return serializePoints(lerped);
}

/**
 * Lerps a single value based on its type and property name.
 */
function lerpValue(key: string, valA: any, valB: any, t: number): any {
  // Check equality first before attempting interpolation
  if (valA === valB) {
    return valA;
  }

  valA ??= DEFAULT_VALUE_FOR_KEY[key];
  valB ??= DEFAULT_VALUE_FOR_KEY[key];

  if (valA !== undefined && valB === undefined) {
    return valA;
  } else if (valA === undefined && valB !== undefined) {
    return valB;
  } else if (typeof valA === "number" && typeof valB === "number") {
    return lerp(valA, valB, t);
  } else if (
    key === "points" &&
    typeof valA === "string" &&
    typeof valB === "string"
  ) {
    return lerpPoints(valA, valB, t);
  } else if (
    key === "d" &&
    typeof valA === "string" &&
    typeof valB === "string"
  ) {
    // Interpolate SVG path data using d3-interpolate-path
    const pathInterpolator = interpolatePath(valA, valB);
    return pathInterpolator(t);
  } else if (
    COLOR_PROPS.has(key) &&
    typeof valA === "string" &&
    typeof valB === "string"
  ) {
    // Handle "none" as transparent
    const isANone = valA === "none";
    const isBNone = valB === "none";

    if (isANone || isBNone) {
      // Get the actual color (the one that's not "none")
      const actualColor = isANone ? valB : valA;
      const colorRgb = rgb(actualColor);

      if (colorRgb === null) {
        // If color parsing failed, fall through to error
        throw new Error(
          `Cannot lerp prop "${key}": invalid color value (${actualColor})`,
        );
      }

      // Create transparent version of the color
      const transparentColor = rgb(colorRgb.r, colorRgb.g, colorRgb.b, 0);
      const opaqueColor = rgb(colorRgb.r, colorRgb.g, colorRgb.b, 1);

      // Interpolate between transparent and opaque
      const colorInterp = isANone
        ? interpolateCubehelix(
            transparentColor.formatRgb(),
            opaqueColor.formatRgb(),
          )
        : interpolateCubehelix(
            opaqueColor.formatRgb(),
            transparentColor.formatRgb(),
          );

      return colorInterp(t);
    }

    // Interpolate colors using HCL color space
    const colorInterp = interpolateCubehelix(valA, valB);
    return colorInterp(t);
  } else if (typeof valA === "string" && typeof valB === "string") {
    // Try to parse both as numbers
    const numA = parseFloat(valA);
    const numB = parseFloat(valB);

    if (!isNaN(numA) && !isNaN(numB)) {
      // Both are numeric strings - interpolate and return as string
      return String(lerp(numA, numB, t));
    }

    // Non-numeric strings - can't interpolate
    throw new Error(
      `Cannot lerp prop "${key}": different non-numeric values (${valA} vs ${valB})`,
    );
  } else {
    // Different non-numeric values
    throw new Error(
      `Cannot lerp prop "${key}": different non-numeric values (${valA} vs ${valB})`,
    );
  }
}

/**
 * Lerps between two SVG JSX nodes.
 * Interpolates transforms and recursively lerps children.
 */
export function lerpSvgx(a: Svgx, b: Svgx, t: number): Svgx {
  // console.log("Lerping SVG nodes:", a, b, t);

  // Elements should be the same type
  if (a.type !== b.type) {
    throw new ErrorWithJSX(
      `Cannot lerp between different element types: ${String(
        a.type,
      )} and ${String(b.type)}`,
      <>
        <p className="mb-2">
          During interpolation, I found elements of different types at the same
          path in the "before" and "after" SVG trees. I don't know how to
          interpolate between those, sorry.
        </p>
        {a.props.id === b.props.id && (
          <p className="mb-2">
            (FYI: These elements share the ID{" "}
            <span className="font-mono">{a.props.id}</span>. I would guess that
            you are drawing this element in two different code paths, and they
            don't match up.)
          </p>
        )}
        <PrettyPrint value={a} />
        <div className="my-4">vs</div>
        <PrettyPrint value={b} />
      </>,
    );
  }

  const propsA = a.props as any;
  const propsB = b.props as any;

  // Lerp transform if present
  const transformA = propsA.transform || "";
  const transformB = propsB.transform || "";
  const lerpedTransform = lerpTransformString(transformA, transformB, t);

  // Lerp numeric props (x, y, width, height, etc.)
  const lerpedNumericProps: any = {};
  const allPropKeys = new Set([...Object.keys(propsA), ...Object.keys(propsB)]);

  for (const key of allPropKeys) {
    if (key === "children" || key === "transform") continue;
    // TODO: audit handling of data- props
    if (key.startsWith("data-")) continue;
    if (/^on[A-Z]/.test(key)) continue;
    if (NO_LERP_PROPS.has(key)) continue;

    const valA = propsA[key];
    const valB = propsB[key];

    // Special handling for style objects
    if (
      key === "style" &&
      typeof valA === "object" &&
      typeof valB === "object"
    ) {
      const styleA = valA || {};
      const styleB = valB || {};
      const lerpedStyle: any = {};
      const allStyleKeys = new Set([
        ...Object.keys(styleA),
        ...Object.keys(styleB),
      ]);

      for (const styleKey of allStyleKeys) {
        lerpedStyle[styleKey] = lerpValue(
          styleKey,
          styleA[styleKey],
          styleB[styleKey],
          t,
        );
      }

      lerpedNumericProps[key] = lerpedStyle;
    } else {
      lerpedNumericProps[key] = lerpValue(key, valA, valB, t);
    }
  }

  // Lerp children recursively (skip foreignObject children)
  const childrenA = React.Children.toArray(propsA.children) as Svgx[];
  const childrenB = React.Children.toArray(propsB.children) as Svgx[];

  let lerpedChildren: Svgx[] = [];

  if (!shouldRecurseIntoChildren(a)) {
    // For foreignObject, just use children from A
    lerpedChildren = childrenA;
  } else if (childrenA.length === childrenB.length) {
    lerpedChildren = childrenA.map((childA, i) => {
      const childB = childrenB[i];
      if (React.isValidElement(childA) && React.isValidElement(childB)) {
        return lerpSvgx(childA, childB, t);
      }
      // For text nodes or other non-element children, just use A
      return childA;
    });
  } else {
    // Children counts differ
    prettyLog(childrenA, { label: "Children A" });
    prettyLog(childrenB, { label: "Children B" });
    throw new ErrorWithJSX(
      `Cannot lerp children: different child counts (${childrenA.length} vs ${childrenB.length})`,
      <div>
        <PrettyPrint value={a} />
        <div className="my-4">vs</div>
        <PrettyPrint value={b} />
      </div>,
    );
  }

  return React.cloneElement(a, {
    ...lerpedNumericProps,
    ...(lerpedTransform ? { transform: lerpedTransform } : {}),
    children: emptyToUndefined(lerpedChildren),
  });
}

function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

// # Emerge animation support

type EmergeBounds = {
  rectWidth: number;
  rectHeight: number;
  textY: number | null;
};

/** Finds the first <rect>'s dimensions and first <text>'s y position (direct children only). */
function findEmergeBounds(element: Svgx): EmergeBounds | null {
  const children = React.Children.toArray(
    (element.props as any).children,
  ) as Svgx[];

  let rectWidth: number | null = null;
  let rectHeight: number | null = null;
  let textY: number | null = null;

  for (const child of children) {
    if (React.isValidElement(child)) {
      if (child.type === "rect" && rectWidth === null) {
        const props = child.props as any;
        rectWidth = parseFloat(props.width);
        rectHeight = parseFloat(props.height);
      } else if (child.type === "text" && textY === null) {
        const props = child.props as any;
        textY = parseFloat(props.y);
      }
    }
  }

  if (
    rectWidth !== null &&
    rectHeight !== null &&
    !isNaN(rectWidth) &&
    !isNaN(rectHeight)
  ) {
    return {
      rectWidth,
      rectHeight,
      textY: textY !== null && !isNaN(textY) ? textY : null,
    };
  }
  return null;
}

/** Clone element with modified first <rect> dimensions and first <text> y. */
function cloneWithBounds(element: Svgx, bounds: EmergeBounds): Svgx {
  const props = element.props as any;
  const children = React.Children.toArray(props.children) as Svgx[];

  let foundRect = false;
  let foundText = false;
  const newChildren = children.map((child) => {
    if (React.isValidElement(child)) {
      if (!foundRect && child.type === "rect") {
        foundRect = true;
        return cloneElement(child, {
          width: bounds.rectWidth,
          height: bounds.rectHeight,
        });
      } else if (!foundText && child.type === "text" && bounds.textY !== null) {
        foundText = true;
        return cloneElement(child, { y: bounds.textY });
      }
    }
    return child;
  });

  return cloneElement(element, { children: newChildren });
}

/**
 * Creates a synthetic "before" version of an emerging element.
 *
 * Strategy:
 * 1. If data-emerge-mode="clone", position at origin with full opacity (split/merge)
 * 2. If both elements have rect+text structure, use bounds interpolation
 * 3. Otherwise, fall back to transform scale(0) + opacity 0
 */
function createSyntheticBefore(newElement: Svgx, originElement: Svgx): Svgx {
  const originTransform = (originElement.props as any).transform || "";
  const emergeMode = (newElement.props as any)["data-emerge-mode"];

  if (emergeMode === "clone") {
    const originBounds = findEmergeBounds(originElement);
    const newBounds = findEmergeBounds(newElement);
    if (originBounds && newBounds) {
      const synthetic = cloneWithBounds(newElement, originBounds);
      return cloneElement(synthetic, {
        transform: originTransform || undefined,
      });
    }
    return cloneElement(newElement, {
      transform: originTransform || undefined,
    });
  }

  // Try bounds-based interpolation (nicer for rect+text tree nodes)
  if (emergeMode !== "scale") {
    const originBounds = findEmergeBounds(originElement);
    const newBounds = findEmergeBounds(newElement);
    if (originBounds && newBounds) {
      const synthetic = cloneWithBounds(newElement, originBounds);
      return cloneElement(synthetic, {
        transform: originTransform || undefined,
        opacity: 0,
      });
    }
  }

  // Fallback: scale from 0 at origin's position
  return cloneElement(newElement, {
    transform: originTransform + " scale(0)",
    opacity: 0,
  });
}

export function lerpLayered(
  a: LayeredSvgx,
  b: LayeredSvgx,
  t: number,
): LayeredSvgx {
  // Preprocess: inject synthetic versions of emerging elements in BOTH directions.
  // Bidirectional handling is needed because Delaunay interpolation can flip direction.
  const augmentedA = new Map(a.byId);
  const augmentedB = new Map(b.byId);

  // Forward: elements in B that emerge from elements in A
  for (const [key, bVal] of b.byId) {
    if (!augmentedA.has(key)) {
      const emergeFromId = (bVal.props as any)["data-emerge-from"];
      if (emergeFromId && typeof emergeFromId === "string") {
        const originElement = a.byId.get(emergeFromId);
        if (originElement) {
          augmentedA.set(key, createSyntheticBefore(bVal, originElement));
        }
      }
    }
  }

  // Reverse: elements in A that emerge from elements in B
  for (const [key, aVal] of a.byId) {
    if (!augmentedB.has(key)) {
      const emergeFromId = (aVal.props as any)["data-emerge-from"];
      if (emergeFromId && typeof emergeFromId === "string") {
        const originElement = b.byId.get(emergeFromId);
        if (originElement) {
          augmentedB.set(key, createSyntheticBefore(aVal, originElement));
        }
      }
    }
  }

  // Main lerp loop
  const result = new Map<string, Svgx>();
  const allKeys = new Set([...augmentedA.keys(), ...augmentedB.keys()]);

  for (const key of allKeys) {
    const aVal = augmentedA.get(key);
    const bVal = augmentedB.get(key);

    if (aVal && bVal) {
      result.set(key, lerpSvgx(aVal, bVal, t));
    } else if (aVal) {
      const opacity = +(aVal.props.opacity ?? 1) * (1 - t);
      if (opacity > 1e-3) result.set(key, cloneElement(aVal, { opacity }));
    } else if (bVal) {
      const opacity = +(bVal.props.opacity ?? 1) * t;
      if (opacity > 1e-3) result.set(key, cloneElement(bVal, { opacity }));
    }
  }

  // Merge descendant maps from both inputs. Lerping preserves the
  // parent-child nesting structure, so the descendant info stays valid.
  let descendents: Map<string, Set<string>> | null = null;
  if (a.descendents && b.descendents) {
    descendents = new Map(a.descendents);
    for (const [key, bSet] of b.descendents) {
      const existing = descendents.get(key);
      if (existing) {
        for (const id of bSet) existing.add(id);
      } else {
        descendents.set(key, new Set(bSet));
      }
    }
  } else {
    descendents = a.descendents ?? b.descendents;
  }

  return {
    byId: result,
    descendents,
  };
}

export function lerpLayered3(
  a: LayeredSvgx,
  b: LayeredSvgx,
  c: LayeredSvgx,
  { l0, l1, l2 }: { l0: number; l1: number; l2: number },
): LayeredSvgx {
  if (l0 + l1 < 1e-6) return c;
  const ab = lerpLayered(a, b, l1 / (l0 + l1));
  return lerpLayered(ab, c, l2);
}
