# Study Draft

Proposal for study structure:
- We guide the participant through different parts of the system, pair-code-tutorial style. We are prepared to pretty much tell them everything they should do, step by step. At various points we get a little Socratic with it.
- [...]
- Q: do we do the "nudge open task in structured direction" thing or the "nudge structured tutorial in open direction"?

Note: I'm writing this up in "docs", with the live editors and all, but I don't think we necessarily want to show any of this to the participants. Ideally they are in their editors, with TS completion etc.

## Meta: What do we want to test here?

Top level:
- data-driven, declarative approach – is it more intuitive? "mental model skew"
  - con case: it would actually be easier for me to think about this via the mechanisms that you are obscuring (drop zones, state diagrams, etc.)
  - con case: there's a small space of things that this implements intuitively, outside that small space it's a weird puzzle to make my intent fit into your model
  - con case: there's stuff I wanna do that this just doesn't do

What do we lead them through?
- dragging between enumerated discrete states
  - background
- dragging between states by continuously varying numeric parameters
- composing different drags (like discrete + continuous)
  - multiple continuous drags, composed discretely
  - discrete foreground with continuous background (scratch-style)


## Show and tell

We'll start by showing you the simplest thing you can make with our library – a switch:

<LiveEditor
  code={`
    type State = { status: "on" | "off" };

    const initialState: State = { status: "off" };

    const draggable: Draggable<State> = ({ state, d }) => (
        <g transform={translate(70, 70)}>
          <rect width={120} height={60} rx={30} fill={state.status === "on" ? "#22c55e" : "#d1d5db"} />
          <circle
            transform={translate(state.status === "on" ? 90 : 30, 30)}
            r={26}
            fill="white"
            stroke="#e5e7eb" stroke-width={1}
            style={{ filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.15))" }}
            data-on-drag={() => d.between({ status: "off" }, { status: "on" })}
          />
        </g>
    );

`}
/>

- A `Draggable` is a lot like a React component. It takes some props, and returns JSX. But, no using hooks. Think of it as especially pure.
- In this case, we render a state, which is a status that's "on" or "off". The status controls the position of the circle, as well as the fill.
- Most of this is just drawing the switch. But `data-on-drag` creates the interaction. What this attribute says, attached to this circle, is that, by dragging the circle, we want to be able to move between the "off" state and the "on" state. When we start a drag, the library renders the interface in both states, behind the scenes. It looks at where the circle is, in both renderings. It then uses these positions to figure out how pointer movements should control the drag. We have some inspectors... [TODO]

Any questions?

## Hands-on: Three-way switch

Ok, now we're going to add dragging to an interface that doesn't have it yet. Here's the interface... It's supposed to be a switch, like before, but with three different states it can enter. Take a look over the code, and let me know if it makes sense.

<LiveEditor
  code={`
    type State = { name: "r" | "g" | "b" };

    const initialState: State = { name: "r" };

    const name_to_pos = {
      r: { x: 50, y: 20 },
      g: { x: 16, y: 78 },
      b: { x: 84, y: 78 },
    };

    const name_to_color = {
      r: "#ef4444",
      g: "#22c55e",
      b: "#3b82f6",
    };

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(60, 30)}>
        {/* Target dots */}
        {(["r", "g", "b"] as const).map((name) => (
          <circle
            transform={translate(name_to_pos[name].x, name_to_pos[name].y)}
            r={16}
            fill={name_to_color[name]}
            opacity={0.25}
          />
        ))}

        {/* Draggable knob */}
        <circle
          transform={translate(name_to_pos[state.name].x, name_to_pos[state.name].y)}
          r={16}
          fill={name_to_color[state.name]}
          stroke="white" stroke-width={3}
          style={{ filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))" }}
        />
      </g>
    );
`}
/>

Based on your experience with the switch, can you explain how you think this might be made draggable with our library?

<LiveEditor
  code={`
    type State = { name: "r" | "g" | "b" };

    const initialState: State = { name: "r" };

    const name_to_pos = {
      r: { x: 50, y: 20 },
      g: { x: 16, y: 78 },
      b: { x: 84, y: 78 },
    };

    const name_to_color = {
      r: "#ef4444",
      g: "#22c55e",
      b: "#3b82f6",
    };

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(60, 30)}>
        {/* Target dots */}
        {(["r", "g", "b"] as const).map((name) => (
          <circle
            transform={translate(name_to_pos[name].x, name_to_pos[name].y)}
            r={16}
            fill={name_to_color[name]}
            opacity={0.25}
          />
        ))}

        {/* Draggable knob */}
        <circle
          transform={translate(name_to_pos[state.name].x, name_to_pos[state.name].y)}
          r={16}
          fill={name_to_color[state.name]}
          stroke="white" stroke-width={3}
          style={{ filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))" }}
          data-on-drag={() =>
            d.between({ name: "r" }, { name: "g" }, { name: "b" })
          }
        />
      </g>
    );

`}
/>

Ok, now we'd like to show you a twist. It's important to note that, when we're defining data-on-drag, we have access to the current state, so the drag behavior can depend on the current state.

For instance, suppose we wanted to say that the dot can only be dragged to the next location clockwise. What do you think we would do here?

<LiveEditor
  code={`
    type State = { name: "r" | "g" | "b" };

    const initialState: State = { name: "r" };

    const name_to_pos = {
      r: { x: 50, y: 20 },
      g: { x: 16, y: 78 },
      b: { x: 84, y: 78 },
    };

    const name_to_color = {
      r: "#ef4444",
      g: "#22c55e",
      b: "#3b82f6",
    };

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(60, 30)}>
        {/* Target dots */}
        {(["r", "g", "b"] as const).map((name) => (
          <circle
            transform={translate(name_to_pos[name].x, name_to_pos[name].y)}
            r={16}
            fill={name_to_color[name]}
            opacity={0.25}
          />
        ))}

        {/* Draggable knob */}
        <circle
          transform={translate(name_to_pos[state.name].x, name_to_pos[state.name].y)}
          r={16}
          fill={name_to_color[state.name]}
          stroke="white" stroke-width={3}
          style={{ filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))" }}
          data-on-drag={() => {
            if (state.name === "r") {
              return d.between({ name: "r" }, { name: "b" });
            } else if (state.name === "b") {
              return d.between({ name: "b" }, { name: "g" });
            } else {
              return d.between({ name: "g" }, { name: "r" });
            }
          }}
        />
      </g>
    );

`}
/>


{/* *TODO: smaller step from 1 to 2?*

current gaps:
- they're actually stuff at all
- they're generating states dynamically (function of current state)
- they have to add IDs (we may have to tell them) */}

## Fancier: Reorderable list

Three-way switches are cool, but sort of contrived. Let's go to a larger, more realistic example – a reorderable list.

Here's some starter code which just renders a list:

<LiveEditor
  code={`
    type State = { items: string[] };

    const initialState: State = { items: ["Apples", "Bananas", "Cherries", "Dates"] };

    const W = 160, H = 40, GAP = 8;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(20, 20)}>
        {state.items.map((item, i) => (
          <g
            transform={translate(0, i * (H + GAP))}
          >
            <rect width={W} height={H} rx={6} fill="white" stroke="#d1d5db" stroke-width={1.5} />
            <text x={W / 2} y={H / 2} text-anchor="middle" dominant-baseline="central" font-size={16} fill="#374151">
              {item}
            </text>
          </g>
        ))}
      </g>
    );
`}
/>

First of all, we're curious – how would you go about making this drag-to-reorder-able in your own life?

Ok, now the task – make it drag-to-reorder-able using our library!

Do you want to try your hand first? It would be helpful for us to see your thinking process, even if you get stuck.

[Expect we'll have to lend help, at least with IDs!]

<LiveEditor
  code={`
    type State = { items: string[] };

    const initialState: State = { items: ["Apples", "Bananas", "Cherries", "Dates"] };

    const W = 160, H = 40, GAP = 8;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(20, 20)}>
        {state.items.map((item, i) => (
          <g
            id={item}
            transform={translate(0, i * (H + GAP))}
            data-on-drag={() => {
              const without = state.items.filter((x) => x !== item);
              const options = _.range(without.length + 1).map((j) => ({
                items: [...without.slice(0, j), item, ...without.slice(j)],
              }));
              return d.between(options);
            }}
          >
            <rect width={W} height={H} rx={6} fill="white" stroke="#d1d5db" stroke-width={1.5} />
            <text x={W / 2} y={H / 2} text-anchor="middle" dominant-baseline="central" font-size={16} fill="#374151">
              {item}
            </text>
          </g>
        ))}
      </g>
    );
`}
/>

Cool, great work!

[Q: How did state generation feel?]

Q: Is there anything about the produced interaction that feels unsatisfying? Or another aspect you might want to play with?

[could do draggedId-based z-index?]

We want to show you some other things you can do with this. For instance, right now everything moves around smoothly. But you might want to add a "snap" behavior, which causes the element to snap into place when it's close to a target. [TODO: how might you do this traditionally?] [TODO: how might you do this here?]

<LiveEditor
  code={`
    type State = { items: string[] };

    const initialState: State = { items: ["Apples", "Bananas", "Cherries", "Dates"] };

    const W = 160, H = 40, GAP = 8;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(20, 20)}>
        {state.items.map((item, i) => (
          <g
            id={item}
            transform={translate(0, i * (H + GAP))}
            data-on-drag={() => {
              const without = state.items.filter((x) => x !== item);
              const options = _.range(without.length + 1).map((j) => ({
                items: [...without.slice(0, j), item, ...without.slice(j)],
              }));
              return d.between(options).withSnapRadius(5);
            }}
          >
            <rect width={W} height={H} rx={6} fill="white" stroke="#d1d5db" stroke-width={1.5} />
            <text x={W / 2} y={H / 2} text-anchor="middle" dominant-baseline="central" font-size={16} fill="#374151">
              {item}
            </text>
          </g>
        ))}
      </g>
    );
`}
/>

Ok, now here's a bigger change. You'll notice that, right now, the dragged element is constrained to a linear track. That's because that's the track that connects its rendered locations. (Debugger shows this well!) But often we want to be able to drag stuff around freely. We have a different way to do that. We will show you!

<LiveEditor
  code={`
    type State = { items: string[] };

    const initialState: State = { items: ["Apples", "Bananas", "Cherries", "Dates"] };

    const W = 160, H = 40, GAP = 8;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(20, 20)}>
        {state.items.map((item, i) => (
          <g
            id={item}
            transform={translate(0, i * (H + GAP))}
            data-on-drag={() => {
              const without = state.items.filter((x) => x !== item);
              const options = _.range(without.length + 1).map((j) => ({
                items: [...without.slice(0, j), item, ...without.slice(j)],
              }));
              return d.closest(d.floating(options)).withSnapRadius(5);
            }}
          >
            <rect width={W} height={H} rx={6} fill="white" stroke="#d1d5db" stroke-width={1.5} />
            <text x={W / 2} y={H / 2} text-anchor="middle" dominant-baseline="central" font-size={16} fill="#374151">
              {item}
            </text>
          </g>
        ))}
      </g>
    );
`}
/>

Play with these a bit. Is one or the other the interaction you'd expect here? (Or neither?) Do you see advantages or disadvantages to them?

Another optional riff: ghosts!

<LiveEditor
  code={`
    type State = { items: string[] };

    const initialState: State = { items: ["Apples", "Bananas", "Cherries", "Dates"] };

    const W = 160, H = 40, GAP = 8;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(20, 20)}>
        {state.items.map((item, i) => (
          <g
            id={item}
            transform={translate(0, i * (H + GAP))}
            data-on-drag={() => {
              const without = state.items.filter((x) => x !== item);
              const options = _.range(without.length + 1).map((j) => ({
                items: [...without.slice(0, j), item, ...without.slice(j)],
              }));
              return d.closest(d.floating(options, {ghost: true}));
            }}
          >
            <rect width={W} height={H} rx={6} fill="white" stroke="#d1d5db" stroke-width={1.5} />
            <text x={W / 2} y={H / 2} text-anchor="middle" dominant-baseline="central" font-size={16} fill="#374151">
              {item}
            </text>
          </g>
        ))}
      </g>
    );
`}
/>

Another possible riff: backdrop!

## Second task: Continuous dragging

So far, the state has been discrete — a finite set of options. But sometimes you want continuous control, like a slider. Here's a slider without drag behavior set.

<LiveEditor
  code={`
    type State = { value: number };

    const initialState: State = { value: 100 };

    const W = 240, H = 6, R = 12;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(30, 60)}>
        {/* Track */}
        <rect width={W} height={H} rx={H / 2} fill="#e5e7eb" y={-H / 2} />
        {/* Filled portion */}
        <rect width={state.value} height={H} rx={H / 2} fill="#3b82f6" y={-H / 2} />
        {/* Thumb */}
        <circle
          id="thumb"
          transform={translate(state.value, 0)}
          r={R}
          fill="white" stroke="#d1d5db" stroke-width={1.5}
          style={{ filter: "drop-shadow(0 1px 3px rgba(0,0,0,0.15))" }}
        />
      </g>
    );
`}
/>

How do you think our library might approach this?

<LiveEditor
  code={`
    type State = { value: number };

    const initialState: State = { value: 100 };

    const W = 240, H = 6, R = 12;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(30, 60)}>
        {/* Track */}
        <rect width={W} height={H} rx={H / 2} fill="#e5e7eb" y={-H / 2} />
        {/* Filled portion */}
        <rect width={state.value} height={H} rx={H / 2} fill="#3b82f6" y={-H / 2} />
        {/* Thumb */}
        <circle
          id="thumb"
          transform={translate(state.value, 0)}
          r={R}
          fill="white" stroke="#d1d5db" stroke-width={1.5}
          style={{ filter: "drop-shadow(0 1px 3px rgba(0,0,0,0.15))" }}
          data-on-drag={() => d.vary(state, ["value"])}
        />
      </g>
    );
`}
/>

And BTW we can do constraints:

<LiveEditor
  code={`
    type State = { value: number };

    const initialState: State = { value: 100 };

    const W = 240, H = 6, R = 12;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(30, 60)}>
        {/* Track */}
        <rect width={W} height={H} rx={H / 2} fill="#e5e7eb" y={-H / 2} />
        {/* Filled portion */}
        <rect width={state.value} height={H} rx={H / 2} fill="#3b82f6" y={-H / 2} />
        {/* Thumb */}
        <circle
          id="thumb"
          transform={translate(state.value, 0)}
          r={R}
          fill="white" stroke="#d1d5db" stroke-width={1.5}
          style={{ filter: "drop-shadow(0 1px 3px rgba(0,0,0,0.15))" }}
          data-on-drag={() =>
          d.vary(state, ["value"], {
          constraint: (s) => [lessThan(0, s.value), lessThan(s.value, W)],
        })
          }
        />
      </g>
    );
`}
/>

Here's something for you to try: a rotary dial, so far without a drag behavior.

<LiveEditor
  code={`
    type State = { angle: number };

    const initialState: State = { angle: 0 };

    const CX = 200, CY = 120, R = 60;
    const TICKS = 12;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g>
        {/* Dial */}
        <g
          id="dial"
          transform={translate(CX, CY) + rotateDeg(state.angle)}
        >
          <circle
            r={R}
            fill="#f9fafb" stroke="#d1d5db" stroke-width={2}
            style={{ filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.15))" }}
          />
          <line
            x1={0} y1={0} x2={R - 14} y2={0}
            stroke="#374151" stroke-width={3} stroke-linecap="round"
          />
        </g>

        {/* Tick marks */}
        {_.range(TICKS).map((i) => (
          <line
            transform={translate(CX, CY) + rotateDeg(i * 360 / TICKS)}
            x1={R + 6} y1={0} x2={R + 16} y2={0}
            stroke="#9ca3af" stroke-width={2} stroke-linecap="round"
          />
        ))}
      </g>
    );

`}
/>

Solution:


<LiveEditor
  code={`
    type State = { angle: number };

    const initialState: State = { angle: 0 };

    const CX = 200, CY = 120, R = 60;
    const TICKS = 12;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g>
        {/* Dial */}
        <g
          id="dial"
          transform={translate(CX, CY) + rotateDeg(state.angle)}
        >
          <circle
            r={R}
            fill="#f9fafb" stroke="#d1d5db" stroke-width={2}
            style={{ filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.15))" }}
            data-on-drag={() => d.vary(state, ["angle"])}
          />
          <line
            x1={0} y1={0} x2={R - 14} y2={0}
            stroke="#374151" stroke-width={3} stroke-linecap="round"
          />
        </g>

        {/* Tick marks */}
        {_.range(TICKS).map((i) => (
          <line
            transform={translate(CX, CY) + rotateDeg(i * 360 / TICKS)}
            x1={R + 6} y1={0} x2={R + 16} y2={0}
            stroke="#9ca3af" stroke-width={2} stroke-linecap="round"
          />
        ))}
      </g>
    );

`}
/>


## Third task: Composition

TODO: Be more incremental first? Nah.


<LiveEditor
  code={`
    type Block = { id: string; pos: number; track: number; color: string };
    type State = { blocks: Block[] };

    const initialState: State = {
      blocks: [
        { id: "Cats", pos: 10, track: 0, color: "#3b82f6" },
        { id: "Dogs", pos: 100, track: 1, color: "#ef4444" },
        { id: "Clouds", pos: 50, track: 2, color: "#22c55e" },
      ],
    };

    const TH = 36, GAP = 6, BW = 80, TW = 340;

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(10, 10)}>
        {/* Track backgrounds */}
        {_.range(3).map((t) => (
          <rect
            y={t * (TH + GAP)} width={TW} height={TH}
            rx={4} fill="#f3f4f6" stroke="#e5e7eb" stroke-width={1}
          />
        ))}

        {/* Blocks */}
        {state.blocks.map((block, i) => (
          <g
            id={block.id}
            transform={translate(block.pos, block.track * (TH + GAP))}
            data-on-drag={() =>
              d.closest(_.range(3).map((t) =>
                d.vary(produce(state, (draft) => { draft.blocks[i].track = t; }), ["blocks", i, "pos"])
              ))
            }
          >
            <rect
              width={BW} height={TH} rx={6} fill={block.color}
              style={{ filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.15))" }}
            />
            <text
              x={BW / 2} y={TH / 2}
              text-anchor="middle" dominant-baseline="central"
              font-size={13} font-weight="600" fill="white"
            >
              {block.id}
            </text>
          </g>
        ))}
      </g>
    );

`}
/>

With overlap avoidance:

<LiveEditor
  code={`
    type Block = { id: string; pos: number; track: number; color: string };
    type State = { blocks: Block[] };

    const initialState: State = {
      blocks: [
        { id: "Cats", pos: 10, track: 0, color: "#3b82f6" },
        { id: "Dogs", pos: 100, track: 1, color: "#ef4444" },
        { id: "Clouds", pos: 50, track: 2, color: "#22c55e" },
      ],
    };

    const TH = 36, GAP = 6, BW = 80, TW = 340;

    function amountOfOverlap(state: State): number {
      let total = 0;
      for (let i = 0; i < state.blocks.length; i++) {
        for (let j = i + 1; j < state.blocks.length; j++) {
          const a = state.blocks[i], b = state.blocks[j];
          if (a.track !== b.track) continue;
          const overlap = Math.min(a.pos + BW, b.pos + BW) - Math.max(a.pos, b.pos);
          if (overlap > 0) total += overlap;
        }
      }
      return total;
    }

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(10, 10)}>
        {/* Track backgrounds */}
        {_.range(3).map((t) => (
          <rect
            y={t * (TH + GAP)} width={TW} height={TH}
            rx={4} fill="#f3f4f6" stroke="#e5e7eb" stroke-width={1}
          />
        ))}

        {/* Blocks */}
        {state.blocks.map((block, i) => (
          <g
            id={block.id}
            transform={translate(block.pos, block.track * (TH + GAP))}
            data-on-drag={() =>
              d.closest(_.range(3).map((t) =>
                d.vary(produce(state, (draft) => { draft.blocks[i].track = t; }), ["blocks", i, "pos"], {constraint: amountOfOverlap})
              ))
            }
          >
            <rect
              width={BW} height={TH} rx={6} fill={block.color}
              style={{ filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.15))" }}
            />
            <text
              x={BW / 2} y={TH / 2}
              text-anchor="middle" dominant-baseline="central"
              font-size={13} font-weight="600" fill="white"
            >
              {block.id}
            </text>
          </g>
        ))}
      </g>
    );

`}
/>

## Bonus: Nested composition

What if you combine a slider and a switch? Here, the thumb slides vertically, and the knob on it toggles horizontally:

<LiveEditor
  code={`
    type State = { pos: number; status: "on" | "off" };

    const initialState: State = { pos: 80, status: "off" };

    const draggable: Draggable<State> = ({ state, d }) => (
      <g transform={translate(50, 10)}>
        {/* Vertical track */}
        <rect x={-3} width={6} height={200} rx={3} fill="#e5e7eb" />

        {/* Thumb (slides vertically) */}
        <g
          id="thumb"
          transform={translate(0, state.pos)}
          data-on-drag={() => d.vary(state, ["pos"])}
        >
          <rect x={-30} y={-15} width={60} height={30} rx={15}
            fill={state.status === "on" ? "#22c55e" : "#d1d5db"}
          />
          {/* Knob (toggles horizontally) */}
          <circle
            id="knob"
            data-z-index={10}
            transform={translate(state.status === "on" ? 15 : -15, 0)}
            r={12}
            fill="white" stroke="#e5e7eb" stroke-width={1}
            style={{ filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.15))" }}
            data-on-drag={() =>
              d.closest([
                d.vary({ ...state, status: "off" }, ["pos"]),
                d.vary({ ...state, status: "on" }, ["pos"]),
              ])
            }
          />
        </g>
      </g>
    );
`}
/>
