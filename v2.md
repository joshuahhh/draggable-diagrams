# v2 spec

We're going to make a new version of DragSpec & ManipulableDrawer. It's going to be cleaner, more expressive, and more conceptually uniform. I don't 100% understand how it works so far, but I have some ideas how it will look.

First of all: Our scope (for now) is floating stuff plus params stuff. We will figure out "span" stuff later.

How do we do floating stuff? By specifying accessible discrete states:

```
states([state1, state2, state3])
```

As the drag-spec for an element, this is equivalent to `floating([state1, state2, state3])` today.

That is, it does a Voronoi thing – the backdrop will reflect whichever state is closest, while the dragged element moves in the foreground.

How do we do params stuff? By specifying a state with paths to vary:

```
state(state1).vary([...path1...], [...path2...])
```

This is the equivalent of `vary(state1, [...path1...], [...path2...])`. If we wanted to leave out the explicit starting state `state1` to say "start with the current state", we could write:

```
curState.vary([...path1...], [...path2...])
```

(`curState` is a built-in value that represents the current state.)

Note a few things here: We're using a fluent API, where we chain modifiers like `vary`. Also, we start with `state(state1)`, which is equivalent to `states([state1])`. If we just wrote `states([state1])`, that would mean "wherever you drag, you're in `state1`". But with this added-on `vary`, we take that `state1` as a starting state and use numerical optimization to vary the numbers at the paths, no matter where we are in the plane.

Since we can put `state(state1)` before `.vary`, this invites putting `states([state1, state2])` before `.vary`. You can do this! This means there will be a region of the plane where dragging will produce varied versions of `state1` and a region where it will produce varied versions of `state2`.

One note: There will likely be discontinuities in rendered backdrop when transitioning across the border between these regions. We should use spring-driven interpolation to make this smooth, though after a short moment (when the spring has converged) dragging within a `vary`-driven region should be tight, without a spring. This is a _universal pattern in v2_ – discontinuities are always smoothed with transient spring-driven interpolation.

Ok, but – what will the two regions be for `states([state1, state2]).vary(...)`? I'm not sure. There are two plausible answers:

1. The same as the regions for `states([state1, state2])` – that is, Voronoi regions defined from `state1` and `state2`.
2. When we drag to a certain point, run numerical optimization for varying `state1` and `state2`. Each will give a solution with a certain degree of "frustration" – distance from the desired element position to its solved (constrained) position. Whichever of these is smaller dominates. The border between the regions is then implicitly defined as a locus of points equidistant from two curves. (If the curves actually overlap, then the user's specified an ambiguous situation and we don't really need to do a good job supporting it.)

The latter situation feels a lot like the drag spec:

```
[state(state1).vary(...), state(state2).vary(...)]
```

Here, it feels more unambiguously true that, once we've taken `state(state1)` and expanded it into `state(state1).vary(...)`, we've lost any trace of `state1` itself, and are now considering a curve of varied possibilities with a distance field around it – so we must be in situation #2. On the other hand, it seems more likely that `states([state1, state2])` still "remembers" the identities of `state1` and `state2` themselves, and might use them to define regions. We will, in fact, see this soon with "backdrops".

You know what? I'm kind of thinking we don't actually gain anything by having `.vary` operate on drag specs rather than individual states. Maybe we just do `vary(state1, [...path1...], [...path2...])` like before?

## Backdrops

A common pattern is "transition into this thing if you're close enough; otherwise do this other thing". That's a backdrop!

If you write:

```
states([state1, state2, state3])
.withBackdrop(stateBackdrop)
```

that means "if we're close enough to one of these states, behave like `states([state1, state2, state3])` (Voronoi-style); otherwise, show `stateBackdrop` and transition to it on pointer release".

One thing to note here – this behavior can't be defined purely by the behavior of `states([state1, state2, state3])`. That is, `states([state1, state2, state3])` defines a map from desired positions to appearances and target states. That's not enough to produce this behavior – you also need to know, for a given desired position, how far this behavior places the dragged element from the desired position, so that when it's "too far", we can go to the backdrop.

Actually, maybe that means the behavior CAN be defined purely by the behavior of `states([state1, state2, state3])`? I kinda thought this value would have to encode some extra meta-data about "radiuses around state1/2/3". But really, every drag spec like this is going to define a "state to transition to if you release your pointer at position X" callback, so maybe `withBackdrop` can just call that, see if we're "too far", and switch to the backdrop if so? Huh!

Anyway, what does "too far" mean? So far, we've just hard-coded that in the engine as a distance, like 50px or something. At the very least, that should be configurable in an option, like `.withBackdrop(..., {radius: 100})`. I'm also curious about using an overlap heuristic – test if the dragged element overlaps its position in the rendered state, perhaps with some extra radius.

Ok! What other things can we do here? Well, as we've done in v1, we should be able to do `vary`-driven backdrops:

```
states([state1, state2, state3])
.withBackdrop(vary(startingState, [...path...]))
```

We should also be able to do something new: `vary`-driven foregrounds with `vary`-driven backgrounds:

```
vary(frontState, [...path1...])
.withBackdrop(vary(backState, [...path2...]))
```

This could be used, for instance, to have a "planet" that can be moved freely in X & Y (the `backState` vary), but which can also lock onto an "orbit" around a star (the `frontState` vary). That's new!

Reminder: Transitioning into and out of backdrops should always be smoothed with temporary spring transitions!

Nomenclature note: I'm feeling like we should use the terms "foreground" and "background", not "backdrop". I picked "backdrop" to not interfere with the use of "background" for "the diagram rendered behind the floating element", but that's an internal name, and is lower-priority. Maybe we should call that internal thing the "backdrop".

## Composability

In case it isn't clear yet: We're shooting for a high degree of uniformity and composability. You should be able to do things like:

```
states([state1, state2, state3])
.withBackdrop(
  states([state4, state5, state6])
  .withBackdrop(
    states([state7, state8, state9])
  )
)
```

Not sure how often anyone will want to use that, but it makes conceptual sense! It says, go to states 1/2/3, and if you're too far from them, go to states 4/5/6, and if you're too far from them, go to states 7/8/9.

A uniform, composable semantics should make the implementation of our engine simple and elegant. It should also open up new expressive possibilities – new features we add should be combinable with old stuff in unexpected ways.

So... what exactly ARE these values? I'm calling them "drag specs", just out of inertia – there might be a better names. What does a drag spec define? While we are dragging, the core things a drag spec needs to tell us are "here's what the diagram should look like right now" and "here's the state we'll transition to if you release the drag here". Per discussion above, I thought that it might need to offer some more metadata, to support the kinds of compositions I described above, but I'm sort of wondering if we can get away without that. It's worth a shot.

## To be determined

There's a lot I'm not sure about here. I'm happy to move forward and prototype this whole new thing without having answers, but here they are to think about:

- What do we do with `span`? I'm thinking it might just become a new "foreground". Then, by default, we would just Voronoi ourselves onto it, but we could also add a backdrop. That makes it a sort of atomic "leaf node" in the broader picture, which doesn't sound _tremendously_ composable. But honestly, span stuff isn't where the center of mass of this project is anymore. I want to keep it, and I want it to not be entirely separated from the world, but we don't need to unnecessarily wrack our brain about it? (If we did want to wrack our brain, we would ask – is it possible to put more things INSIDE of spans, like varys?)

- How do we control the display of ghosts? How does that integrate into these hierarchies?

- How do we control snapping behavior? I kind of like the idea of having a "snapWithin" combinator, which changes the display behavior of a drag-spec within a radius to preview as the final state. Then you'd say things like `states(myStates.map((s) => s.snapWithin(5)))`, or maybe there's a better idiom than that? Or maybe you can say `states(myStates).snapWithin(5)`, if there's a way to make that make actual sense and not just be a one-off illegitimate shortcut?

- How do we control animation / interpolation across boundaries? E.g. what if a user doesn't want animation across a particular boundary?

## Tactics

To try this out, we will set up a parallel infrastructure:

- DragSpec2.ts
- ManipulableDrawer2.tsx
- demo-diagrams2
- a new route
- [etc.]
